# Import functions and libraries
import numpy as np, matplotlib.pyplot as plt, time
from numpy import *
from numpy.fft import *
from matplotlib.pyplot import *
from rtlsdr import RtlSdr
from scipy import signal 
import pyaudio
import time
import warnings
import os

warnings.filterwarnings("ignore")

def locateBurst(x, fs):
        # use to  find the starting and ending FCCH bursts in a given signal part
        #  Inputs:
        #           x  - signal array
        #           fs - sampling frequency
        #
        #  Outputs:
        #           fcch_idx_pos and array which havw starting and ending indexes of bursts
        #
        
        burst_t = 576.9e-6 #seconds
        half_len = fs*burst_t//2 + 3

        normed = (abs(x)/max(abs(x)))**2
        normed[normed < 0.5] = 0
        
        pulses = []
        for i in range(len(normed)-2):
            if normed[i+1]>normed[i] and normed[i+1]>normed[i+2]:
                if(i-half_len < 0 or i+half_len >= len(normed)-2):
                    continue
                else:
                    pulses += [(i+1-half_len, i+1+half_len)]

        return np.array(pulses)   


def findOffset(data, fcch_pos, fcc, nbw):
        # use to calculate the offset
        # Inputs:
        #        data - an array of data
        #        fcch_pos - positions of fcch bursts generated by locateBurst
        #        fcc   - estimated fcch frequency, which you used to demodulate the data
        #        nbw  -   sampling rate of the data
        #
        # Outputs:
        #       offset - The estimated frequency offset with respect to ideal fcch frequency.
        
        L = nbw//10 # for fft res = 10 Hz
        
        ffts = []
        # print(type(fcch_pos))
        fcch_pos = fcch_pos.astype(np.int64)
        for i in range(len(fcch_pos)):
            ffts += [np.fft.fft(append(data[fcch_pos[i][0]:fcch_pos[i][1]], zeros(L-(fcch_pos[i][1]-fcch_pos[i][0]))))]
        mean_power = np.mean(np.fft.fftshift(abs(np.array(ffts)))**2, axis=0)
        idx = np.argmax(mean_power)
        fcch = idx*(nbw/L)
        
        return (fcch) - (1625000.0 / 6.0) / 4.0  


def main():
    
    requirement = input("Having SDR?")
    fc = 879.347e6 # Default Frequency

    if requirement.upper() == "YES":
        #SDR presets
        fs = 240000
        fc = input("  GSM Frequency in your area? 879.347e6 for GSM-850 and 948.779e6 for GSM-900   ")
        
        # fc = 948.779e6   #879.347e6 for GSM-850 #948.779e6 for GSM-900 # 1090 MHz center frequency
        gain = 32
        ppm = 1

        sdr = RtlSdr()
        sdr.sample_rate = fs    # sampling rate
        sdr.gain = gain
        sdr.center_freq = fc
        sdr.set_freq_correction(ppm)
        # collect data and throw away the first 2000 samples, since they are no good!
        data = sdr.read_samples(25600*3)[2048:]
        sdr.close()

    else:
        # In case you don't have a base station, download gsm.npy and uncomment the next line
        data = np.fromfile('test/gsm.npy',np.complex128)

        # throw away the first 2000 samples, since they are no good!
        data = data[2048:]
        #SDR presets
        fs = 240000
        gain = 32
        ppm = 1

    print("----Loading----")
    
    backup_data = np.copy(data)

    # sampling rate fs = 240e3 samples/second
    burst_t = 576.9e-6 #seconds
    burst_len = 1 + fs*burst_t//1 # == 139 samples
    fcc = fc + 640000 # approximate frequency of the FCCH burst
    demod_data = np.exp(-1j * fcc * np.linspace(0,len(data),len(data)))*data

    h = signal.firwin(141,7500,nyq=2400000.0/2,window='hanning')
    filtered_data = signal.fftconvolve(demod_data, h)[::10]
    
    pos = locateBurst(filtered_data,fs/10)

    offset = findOffset(filtered_data, pos, fcc,fs)
    print("OFFSET :" , offset)

    ppm = offset / (fcc + (1625000.0 / 6.0) / 4.0)*1e6
    print("PPM :" , ppm)

if __name__ ==  "__main__":
    main() 


